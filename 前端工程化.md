# 前端工程化

## day48-邂逅Node.js开发

### 一、Node.js是什么

#### 1.1.Node.js的认识

- 官方对 Node.js 的定义：
  - Node.js是基于V8 JavaScript引擎的JavaScript运行时环境


- 也就是说 Node.js 基于 V8 引擎来执行 JavaScript 的代码，但是不仅仅只有 V8 引擎：
- 前面我们知道 V8 可以嵌入到任何 C ++ 应用程序中，无论是 Chrome 还是 Node.js ，事实上都是嵌入了 V8 引擎来执行
  JavaScript 代码；
- 但是在 Chrome 浏览器中，还需要解析、渲染 HTML 、 CSS 等相关渲染引擎，另外还需要提供支持浏览器操作的 API 、浏
  览器自己的事件循环等；
- 另外，在 Node.js 中我们也需要进行一些额外的操作，比如文件系统读 / 写、网络 IO 、加密、压缩解压文件等操作



#### 1.2.浏览器和Node.js架构区别

- ![image-20241013105653907](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241013105653907.png)



#### 1.3.Node.js架构

-  我们来看一个单独的 Node.js 的架构图：
  - 我们编写的 JavaScript 代码会经过 V8 引擎，再通过 Node.js 的 Bindings ，将任务放到 Libuv 的事件循环中；
  -  libuv （ Unicorn Velociraptor— 独角伶盗龙）是使用 C 语言编写的库；
  -  libuv 提供了事件循环、文件系统读写、网络 IO 、线程池等等内容；
- ![image-20241013105759697](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241013105759697.png)



### 二、Node的应用场景

#### 2.1.应用场景

- Node.js 的快速发展也让企业对 Node.js 技术越来越重视，在前端招聘中通常会对 Node.js 有一定的要求，特别对于高级前端开发工程师， Node.js 更是必不可少的技能
-  应用一：目前前端开发的库都是以 node 包的形式进行管理；
-  应用二： npm 、 yarn 、 pnpm 工具成为前端开发使用最多的工具；
-  应用三：越来越多的公司使用 Node.js 作为 web 服务器开发、中间件、代理服务器；
-  应用四：大量项目需要借助 Node.js 完成前后端渲染的同构应用；
-  应用五：资深前端工程师需要为项目编写脚本工具（前端工程师编写脚本通常会使用 JavaScript ，而不是 Python 或者 shell ）；
-  应用六：很多企业在使用 Electron 来开发桌面应用程序；



### 三、Node安装和管理

#### 3.1.Node的安装

- Node.js 是在 2009 年诞生的，目前最新的版本是分别是 LTS 16.15.1 以及 Current 18.4.0 ：
  -  LTS 版本：（ Long-term support, 长期支持）相对稳定一些，推荐线上环境使用该版本；
  -  Current 版本：最新的 Node 版本，包含很多新特性；
-  这些我们选择什么版本呢？
  -  如果是学习使用，可以选择 current 版本；
  -  如果是公司开发，建议选择 LTS 版本（面向工作，选择 LTS 版本）；
-  Node 的安装方式有很多：
  - 可以借助于一些操作系统上的软件管理工具，比如 Mac 上homebrew ， Linux 上的 yum 、 dnf 等；
  -  也可以直接下载对应的安装包下载安装；
- 我们选择下载安装，下载自己操作系统的安装包直接安装就可以了
  - window 选择 .msi 安装包， Mac 选择 .pkg 安装包， Linux 会在后续部署中讲解；
  - 安装过程中会配置环境变量（让我们可以在命令行使用）；
  - 并且会安装 npm （Node Package Manager ）工具；



#### 3.2.Node的版本工具(了解,可以不用安装)

-  在实际开发学习中，我们只需要使用一个 Node 版本来开发或者学习即可。
- 如果你希望通过可以快速更新或切换多个版本时，可以借助于一些工具：
  -  nvm ： Node Version Manager ；
  -  n ： Interactively Manage Your Node.js Versions （交互式管理你的 Node.js 版本）
- 问题：这两个工具都不支持 window
- 解决方法:
  - 针对 nvm ，在 GitHub 上有提供对应的 window 版本： https://github.com/coreybutler/nvm-windows
  - 通过 nvm install latest 安装最新的 node 版本
  - 通过 nvm list 展示目前安装的所有版本
  - 通过 nvm use 切换版本



### 四、JavaScript代码执行

#### 4.1.基本使用

- 创建一个js文件,写上JavaScript代码

- 执行方式

  - 浏览器
  - 载入Node环境中执行

- ```
  //abc.js文件
  console.log("first")
  console.log("first")
  console.log("first")
  ```

- 运行方式一

  - 在终端用命令cd进入到文件的目录下
  - 输入命令node abc.js即可运行

- 运行方式二

  - 在abc.js右键点击控制台,在里面和方式一同等操作

  

### 五、Node的输入和输出

#### 5.1.输入和输出

- 创建文件: Node.js

- ```
  
  //1.输出内容
  console.log("Hello World!")
  
  const num1 = 100
  const num2 = 200
  
  console.log(num1 + num2)
  
  
  //2.给程序输入内容
  
  console.log(process.argv)
  
  for(const item of process.argv) {
    console.log(item)
  }
  
  //可以传入参数
  const arg1 = process.argv[2]
  const arg2 = process.argv[3]
  
  console.log(arg1, arg2)
  
  //了解
  setTimeout(() => {
    // console.clear()
    console.trace()
  }, 3000);
  ```

- 右键点击控制台,在里面和方式一同等操作





### 六、Node的全局对象

#### 6.1.基本掌握

- ```
  
  
  //1.类似window的全局对象
  console.log(global)
  
  //2.特殊的全局变量
  //__dirname:当前的文件所在的目录结构(重要)
  console.log(__dirname)
  //__filename:当前目录+文件名称
  console.log(__filename)
  
  //3.模块化时具体学习(重要)
  console.log(module)
  console.log(exports)
  console.log(require)
  
  
  //4.常见的全局对象(了解)
  console.log(process)
  console.log(process.argv)
  
  //5.定时器方法
  setTimeout(() => {
    console.log("setTimeout")
  }, 2000);
  
  setInterval(() => {
    console.log("setInterval")
  }, 3000);
  
  //额外补充:Immediate:立即/立刻
  setImmediate(() => {
    console.log("setImmdiate")
  } )
  
  //额外执行函数
  process.nextTick( () => {
    console.log("nextTick")
  })
  
  //6.全局对象
  console.log(global)
  console.log(globalThis)
  console.log(globalThis === global)
  
  ```



## day48-02-JavaScript模块化

### 一、认识模块化开发

- 到底什么是模块化、模块化开发呢？
- 事实上模块化开发最终的目的是将程序划分成一个个小的结构；
- 这个结构中编写属于自己的逻辑代码，有自己的作用域，定义变量名词时不会影响到其他的结构；
  - 就是在main.js中定义了name，在foo.js中也定义了name但两者不冲突因为都有属于自己的作用域
-  这个结构可以将自己希望暴露的变量、函数、对象等导出给其结构使用；
-  也可以通过某种方式，导入另外结构中的变量、函数、对象等；
-  上面说提到的结构，就是模块；按照这种结构划分开发程序的过程，就是模块化开发的过程；
- 无论你多么喜欢 JavaScript ，以及它现在发展的有多好，它都有很多的缺陷：
  -  比如 var 定义的变量作用域问题；
  -  比如 JavaScript 的面向对象并不能像常规面向对象语言一样使用 class ；
  -  比如 JavaScript 没有模块化的问题
-  对于早期的 JavaScript 没有模块化来说，确确实实带来了很多的问题；



### 二、CommonJS和Node

#### 2.1.两者的关系

- 我们需要知道 CommonJS 是一个规范，最初提出来是在浏览器以外的地方使用，并且当时被命名为 ServerJS ，后来为了体现它的广泛性，修改为 CommonJS ，平时我们也会简称为 CJS 。
  - Node 是 CommonJS 在服务器端一个具有代表性的实现
  -  Browserify 是 CommonJS 在浏览器中的一种实现；
  -  webpack 打包工具具备对 CommonJS 的支持和转换；
-  所以， Node 中对 CommonJS 进行了支持和实现，让我们在开发 node 的过程中可以方便的进行模块化开发：
  - 在 Node 中每一个 js 文件都是一个单独的模块；
  - 这个模块中包括 CommonJS 规范的核心变量： exports 、 module.exports 、 require ；
  -  我们可以使用这些变量来方便的进行模块化开发；
- 前面我们提到过模块化的核心是导出和导入， Node 中对其进行了实现：
  - exports 和 module.exports 可以负责对模块中的内容进行导出；
  - require 函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容；

#### 2.2.exports导出

- exports是一个对象。可以在这个对象中添加很多属性，添加的属性会导出

  - ```
    exports.name = name
    exports.age = age
    ```

- 在另外一个文件中带入

  - ```
    const bar = require("./bar")
    ```

  - 表示 bar文件中导出的（exports）的属性赋值给了bar



#### 2.3.module.exports导出

- 但node是通过module.exports导出
-  Node 中真正用于导出的其实根本不是 exports ，而是 module.export

- 因为 module 才是导出的真正实现者

- 为什么 exports 也可以导出呢

  -  这是因为 module 对象的 exports 属性是 exports 对象的一个引用；

  -  也就是说 module.exports = exports = main 中的 bar



### 三、require函数解析

#### 3.1.require的细节

-  require 是一个函数，可以帮助我们引入一个文件（模块）中导出的对象

-  require 的查找规则是怎么样的呢？

- 常见的查找规则：

  - 导入格式如下： require(X)

  - 情况一： X 是一个 Node 核心模块，比如 path 、 http

    -  直接返回核心模块，并且停止查找

  - 情况二： X 是以 ./ 或 ../ 或 / （根目录）开头的

    - 第一步：将 X 当做一个文件在对应的目录下查找；
       1. 如果有后缀名，按照后缀名的格式查找对应的文件

      2. 如果没有后缀名，会按照如下顺序：
         - 1> 直接查找文件 X
         -  2> 查找 X.js 文件
         -  3> 查找 X.json 文件
         -  4> 查找 X.node 文件

    -  第二步：没有找到对应的文件，将 X 作为一个目录

      -  查找目录下面的 index 文件
        -  1> 查找 X/index.js 文件
        -  2> 查找 X/index.json 文件
        -  3> 查找 X/index.node 文件

    -  如果没有找到，那么报错： not found

    - 情况三
      - ![image-20241015124038196](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241015124038196.png)



#### 3.2.模块的加载过程

- 结论一：模块被第一次引用时模块中的js代码会被运行一次
- 结论二：模块被多次引用时，会缓存 最终只加载一次
  - 因为每个module都有一个属性loaded
  - 当引用被加载时就会从false（未加载）变为true
- 结论三：循环引用的顺序
- ![image-20241015124425546](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241015124425546.png)

- ![image-20241015124436222](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241015124436222.png)

### 四、AMD 和 CMD （了解）

- ![image-20241015124558702](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241015124558702.png)

- ![image-20241015124612995](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241015124612995.png)

- ![image-20241015124627957](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241015124627957.png)



### 五、ESModule用法详细

#### 5.1.认识ES Module

- JavaScript没有模块化一直是他的痛点,社区推出模块化前涌入了一大批模块化规范:CommonJS(用exports/module.exports导出,require导入)、AMD、CMD等
- ES Module和CommonJS 的区别
  - CommonJS是用exports/module.exports导出 require导入
  - 而ES Module是使用import和export的关键字进行导入导出。且它采用编译期 的静态分析方法也加入了动态引用的方式
- 采用ES Module将自动采用严格模式use strict



#### 5.2.案例代码结构组件

- 在浏览器中演示ES6的模块化开发

  - ```
    <script src="./modules/foo.js" type="module"></script>
    <script src="main.js" type="module"></script>
    ```
    
  - 



#### 5.3.export和import的三种导入导出方式

- export

  - 方式一： {}不是对象，只是导出的一个结构规范

  -  export {name: name} ，是错误的写法；

  - ```
    export {}
    ```

  - 方式二：导出时可以给标识符起名字

  - ```
    export {
    name as fname
    }
    ```

  - 方式三

  - ```
    export const name = "ylj"
    ```

- import

  - 方式一

  - 注意事项一：在浏览器中直接使用esmodule时,文件必须加上文件后缀名.js

  - ```
    import{name,age,sayHello} from "./foo.js"
    ```

  - 方式二:导入时给标识符起个别名

  - 使用as关键字

  - ```
    import{name as fname,age,sayHello} from "./foo.js"
    ```

  - 方式三

  - 表示全部

  - ```
    import * as foo from "./foo.js"
    ```

  - 


#### 5.4.export和import结合使用

- ```
  export {name, age} from ("./bar.js")
  ```

- 表示从js文件中导入再导出



#### 5.5.默认导出

- 默认导出 export 时可以不需要指定名字；

- 在导入时不需要使用 {} ，并且可以自己来指定名字；

- 在一个模块中，只能有一个默认导出

- ```
  //1.默认的导出:
  //1.1.定义函数
  
  function parseLyric() {
    return ["歌词"]
  }
  const name = "yls"
  
  {}不是一个对象,是导出的一个语法结构
  // export {
  //   parseLyric,
  //   name
  // }
  
  
  // //1.2.默认导出
  // export default parseLyric
  
  //2.定义标识符直接作为默认导出
  export default function() {
    return ["新歌词"]
  }
  
  //注意事项:应该模块默认只有一个默认导出
  
  ```

- 



### 六、ESModule运行原理





## day49-包管理工具详解npm yarn cnpm npx pnpm

### 一、npm包管理工具

#### 1.1.代码共享方案

- 共享方式
  - 上传到Github上，全球通用都可下载
    - 弊端：必须知道你的代码的Github的地址 并手动下载
    - 需要在自己的项目中手动引用 并管理相关的依赖
    - 不需要使用时需要手动删除
    - 遇到版本升级需要重复上述操作重新下载
  - 使用一个Vue官网
    - 弊端：和上述一样
  - npm regeist
    - 可以直接在终端输入命令： npm install XXX
      - eg:npm install vue
      - 

#### 1.2.包管理工具npm

-  包管理工具npm：
-  Node Package Manager，也就是Node包管理器；
  - 在前端项目中我们也在使用它来管理依赖的包；
  - 比如vue、vue-router、vuex、express、koa、react、react-dom、axios、babel、webpack等等；
- 下载和安装npm工具
  - npm属于node的一个管理工具，所以我们需要先安装Node；
  - node管理工具：https://nodejs.org/en/，安装Node的过程会自动安装npm工具；
- npm管理的包查看、搜索
  -  https://www.npmjs.org/
  - 这是我们安装相关的npm包的官网；
- npm管理的包存放位置
  - 我们发布自己的包其实是发布到registry上面的；
  -  当我们安装一个包时其实是从registry上面下载的包



### 二、package配置文件

#### 2.1.npm的配置文件

- 掌握package.json文件的配置
  - 在控制台输入npm init /  mpm init -y



#### 2.2.常见的属性

- 必须填的属性:name version
  - name:是项目的名称
  - version:是当前项目的版本号
  - description是描述信息 很多时候作为项目的基本描述
  - author是作者相关信息(发布时用到)
  - license是开源协议(发布时用到)
- private属性
  - 防止不小心发布出去
  - 记录当前项目是否为私有
  - 当值为true时npm是不能发布他的 

- main属性

  - 设置程序的入口
  - 比如我们使用axios模块 const axios = require("axios")
  - 如果有main属性 实际上是找到对应的main属性查找文件的

- scripts属性(重要)

  - scripts属性用于配置一些脚本命令 以键值对的形式存在

    - 个人理解:节省输入过多路径,比如要执行node home/src/node/main.js, 可以在配置文件中的scripts属性中

      - ```
        {
          "name": "02_package_demo",
          "version": "1.0.0",
          "main": "index.js",
          "scripts": {
            "start": "node ./src/main.js ", //这样运行 只需要输入 node run start
            "build": "webpack xxx.js"
          },
          "author": "",
          "license": "ISC",
          "devDependencies": {},
          "keywords": [],
          "description": ""
        }
        
        ```

      - 

  - 配置后我们可以通过npm run命令的key来执行这个命令

  - npm start和npm run start的区别

    - 他们是等价的
    - 对于常用的start test stop restart可以省略run直接npmstart等方式运行 最好还是加run

  - dependencies属性

    - dependencies属性是指定无论开发环境还是生成环境都需要依赖的包；
    -  通常是我们项目实际开发用到的一些库模块vue、vuex、vue-router、react、react-dom、axios等等；
    -  与之对应的是devDependencies；

  - devDependencies属性

    - 一些包在生成环境是不需要的，比如webpack、babel等；
    -  这个时候我们会通过 npm install webpack --save-dev 或者 npm install webpack -D，将它安装到devDependencies属性中

  - peerDependencies属性
    -  还有一种项目依赖关系是对等依赖，也就是你依赖的一个包，它必须是以另外一个宿主包为前提的；
    -  比如element-plus是依赖于vue3的，ant design是依赖于react、react-dom



#### 2.3.依赖的版本管理

- npm的包通常都需要遵循semver版本规范: X.Y.Z
  - X主版本号: 当你做了不兼容的 API 修改（可能不兼容之前的版本）；
  - Y此版本号: 当你做了向下兼容的功能性新增（新功能增加，但是兼容之前的版本）；
  - Z修订号 : 当你做了向下兼容的问题修正（没有新功能，修复了之前版本的bug）；
-  ^和~的区别：
  - x.y.z：表示一个明确的版本号；
  -  ^x.y.z：表示x是保持不变的，y和z永远安装最新的版本；
  -  ~x.y.z：表示x和y保持不变的，z永远安装最新的版本；
- 常见的属性(了解)
  - engines属性
    - engines属性用于指定Node和NPM的版本号；
    -  在安装的过程中，会先检查对应的引擎版本，如果不符合就会报错；
    -  事实上也可以指定所在的操作系统 "os" : [ "darwin", "linux" ]，只是很少用到；
  - browserslist属性
    - 用于配置打包后的JavaScript浏览器的兼容情况，参考；
    -  否则我们需要手动的添加polyfills来让支持某些语法；
    -  也就是说它是为webpack等打包工具服务的一个属性（这里不是详细讲解webpack等工具的工作原理，所以不再给出详情）；



### 三、npm install原理

#### 3.1.npm install命令

- 安装npm包分两种情况：
  -  全局安装（global install）： npm install webpack -g;
  -  项目（局部）安装（local install）： npm install webpack
- 全局安装
  - 全局安装是直接将某个包安装到全局：
  -  比如全局安装yarn：
    - npm install yarn -g
  - 但是很多人对全局安装有一些误会：
    - 通常使用npm全局安装的包都是一些工具包：yarn、webpack等；
    -  并不是类似于 axios、express、koa等库文件；
    -  所以全局安装了之后并不能让我们在所有的项目中使用 axios等库；
      npm install 命令



#### 3.2.项目安装

- 项目安装会在当前目录下生成一个 node_modules 文件夹，之前讲解require查找顺序时有讲解过这个包在什么情况下被
  查找；

- 局部安装分为开发依赖和生产依赖

  - 默认安装开发和生产依赖

    - 命令

      - ```
        npm install aixos
        npm i axios
        ```

  - 开发依赖

    - ```
      npm install webpack --save-dev
      //要同时
      npm install webpack webpack-cli -D
      npm install webpack -D
      npm i webpack -D
      ```

  - 根据package.json中的依赖包
  
    - ```
      npm insatll
      ```



#### 3.3.npm install原理(理解)

- 解析
-  npm install会检测是有package-lock.json文件：
  -  没有lock文件
    ✓ 分析依赖关系，这是因为我们可能包会依赖其他的包，并且多个包之间会产生相同依赖的情况；
    ✓ 从registry仓库中下载压缩包（如果我们设置了镜像，那么会从镜像服务器下载压缩包）；
    ✓ 获取到压缩包后会对压缩包进行缓存（从npm5开始有的）；
    ✓ 将压缩包解压到项目的node_modules文件夹中（前面我们讲过，require的查找顺序会在该包下面查找）
  - 有lock文件
    ✓ 检测lock中包的版本是否和package.json中一致（会按照semver版本规范检测）；
    ➢ 不一致，那么会重新构建依赖关系，直接会走顶层的流程；
    ✓ 一致的情况下，会去优先查找缓存
    ➢ 没有找到，会从registry仓库下载，直接走顶层流程；
    ✓ 查找到，会获取缓存中的压缩文件，并且将压缩文件解压到node_modules文件夹中；

- ![image-20241017211715381](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241017211715381.png)



#### 3.4.package-lock.json(理解)

-  package-lock.json文件解析：
  - name：项目的名称；
  - version：项目的版本；
  -  lockfileVersion：lock文件的版本；
  -  requires：使用requires来跟踪模块的依赖关系；
  -  dependencies：项目的依赖
    - 当前项目依赖axios，但是axios依赖follow-redireacts；
    -  axios中的属性如下：
      -  version表示实际安装的axios的版本；
      -  resolved用来记录下载的地址，registry仓库中的位置；
      -  requires/dependencies记录当前模块的依赖；
      -  integrity用来从缓存中获取索引，再通过索引去获取压缩包文件；
- ![image-20241017210848769](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241017210848769.png)



#### 3.5.npm其他命令(了解)

- 我们这里再介绍几个比较常用的：
- 卸载某个依赖包：
  - npm uninstall package
    npm uninstall package --save-dev
    npm uninstall package -D
- 强制重新build
  - npm rebuild
-  清除缓存
  - npm cache clean
- npm的命令其实是非常多的：
  - https://docs.npmjs.com/cli-documentation/cli
  - 更多的命令，可以根据需要查阅官方文档





### 四、yarn、cnpm、npx

#### 4.1.yarn

- 另一个node包管理工具yarn
  -  yarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具；
  -  yarn 是为了弥补 早期npm 的一些缺陷而出现的；
  -  早期的npm存在很多的缺陷，比如安装依赖速度很慢、版本依赖混乱等等一系列的问题；
  -  虽然从npm5版本开始，进行了很多的升级和改进，但是依然很多人喜欢使用yarn；

- ![image-20241017215202731](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241017215202731.png)



#### 4.2.cnpm

- 由于一些特殊的原因，某些情况下我们没办法很好的从 https://registry.npmjs.org下载下来一些需要的包。

- 查看npm镜像：

  - ```
    npm config get registry # npm config get registry
    ```

-  我们可以直接设置npm的镜像：

  - ```
    npm config set registry https://registry.npm.taobao.org
    ```

- 但是对于大多数人来说并不希望将npm镜像修改了：

  - 第一，不太希望随意修改npm原本从官方下来包的渠道；
  -  第二，担心某天淘宝的镜像挂了或者不维护了，又要改来改去；

- 这个时候，我们可以使用cnpm，并且将cnpm设置为淘宝的镜像：

  - ```
    npm install -g cnpm --registry=https://registry.npm.taobao.org
    cnpm config get registry # https://r.npm.taobao.org/
    ```

    

#### 4.3.npx工具

- 使用他来调用项目中的某个模块

- 使用命令

  ​	默认使用全局下的webpack因此使用下列命令查找局部的webpack

  - 用于查找当前目录下webpack的版本,优先在node_module中的.bin中查找,这样该项目打包就是使用这个版本,否则就是使用全局的webpack版本

    ```
    npx webpack --version
    ```

- 打包命令

- 使用当前项目下webpack版本

  ```
  npx webpack
  ```

- 但开发每次都要执行上述命令比较麻烦,因此可以在package.json中的scripts中添加"build"(这个名字可以自己命名):"npx webpack ",再在终端执行: npm run build即可,就会创建一个dlist包

  - 没必要在scripts中写npx

  - 则最终是

    - 因为webpack优先在该项目中的node_module中查找如果没有就会去全局查找

      ```
       scripts{
       "build": "webpack"
       }
      ```



### 五、发布直接的开发包

#### 5.1.npm发布自己的包

- 注册npm账号
  - http://www.npmjs.cpm/
- 输入命令 npm login进行登录
- 修改 package.json
- 发布到npm registry上
  - npm publish

- 更新仓库
  - 修改版本号:最好遵循semver规范,x.y.z    y是增加新功能,z是修复bug
  - 重新发布


- 删除发布的包
  - npm unpublish
- 让发布的包过期
- npm deprecate



### 六、pnpm使用和原理

#### 6.1.认识pnpm

- pnpm: Performant npm缩写 高性能pnpm
  - 速度快 节省磁盘空间的软件包管理器



#### 6.2.硬链接和软链接的概念

- 硬链接的定义hard link
  - 维基百科:是电脑文件系统中的多个文件平等的共享一个文件存储单元
  - 删除一个文件名字后 还可以用其他名字继续访问该文件
- 符号链接(软链接)
  - 是一类特殊文件
  - 其中包含有一条以绝对路径或者相对路径的形式指向其他文件或者目录的引用



#### 6.3.硬链接和软链接的演练(了解)

- 文件的拷贝:就是复制粘贴,相当于两个单独的文件,各自修改都不关各自的事

  - ```
    window: copy foo.js foo_copy.js
    macos : cp foo.js foo_copy.js
    ```

- 文件的硬链接

  - 就是多个文件共享同一个文件资源,

  - ```
    window: mklink /H (要硬链接的文件名称)aaa_hard.js (希望被硬链接的文件) aaa.js
    ```

  - 两者无论修改哪一个都会被修改

  - ![image-20241018192253463](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241018192253463.png)

- 文件的软链接

  - ```
    window: mklink aaa_soft.js aaa.js
    //上述暂时不能用,原因未知,在AI中查找到另一命令,并且要以管理员的身份运行终端
    New-Item -ItemType SymbolicLink -Path ylj_soft.js -Target ylj.js
    
    macos : ln -s foo.js foo_copy.js
    ```

  - 就是相当于快捷方式,快捷方式保存的是相对路径或者绝对路径,双击点开实则是打开这个路径下的资源

  - ![image-20241018192511529](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241018192511529.png)



#### 6.4.理解pnpm

- 当使用 npm 或 Yarn 时，如果你有 100 个项目，并且所有项目都有一个相同的依赖包，那么， 你在硬盘上就需要保存 100 份该相同依赖包的副本。
-  如果是使用 pnpm，依赖包将被 存放在一个统一的位置，因此：
  -  如果你对同一依赖包使用相同的版本，那么磁盘上只有这个依赖包的一份文件；
  -  如果你对同一依赖包需要使用不同的版本，则仅有 版本之间不同的文件会被存储起来；
  -  所有文件都保存在硬盘上的统一的位置：
    -  当安装软件包时， 其包含的所有文件都会硬链接到此位置，而不会占用 额外的硬盘空间；
    -  这让你可以在项目之间方便地共享相同版本的 依赖包；
- ![image-20241018192624921](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241018192624921.png)



#### 6.5.pnpm创建非扁平的node_module

- 当我们要使用第三方库的时候就会npm 一个库

  - ```
    npm install axios
    ```

  - 这些第三方库还会依赖其他包这些包本不属于该项目的包,但但因为这第三方库要使用才会存在,也就意味着可以获取到本不属于该项目的依赖包.但如果其他库也要使用这个包就会又创建相同的包,也就是会重复占用内存

  - pnpm就可以解决这一问题

  - 获取的第三方库一般都在node_module中,为了解决上述问题node_module中还会有个.pnpm文件夹,创建的库在node_module中是软链接,其真实路径在.pnpm中下的库的名称文件夹中,这个文件夹中又有许多这个库依赖包的软链接,这些包路径指向registry

  - 也就意味着若其他库需要使用该软链接依赖的包就可同样建立软链接,减少占据空间,也解决了本不属于该项目得到依赖的包

  - ![image-20241018200121869](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241018200121869.png)



#### 6.5.pnpm的安装和使用

- 安装

  - -g 是安装到全局

  - ```
    npm install -g pnpm
    ```

- ![image-20241018200939420](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241018200939420.png)

-  更多命令和用法可以参考pnpm的官网：https://pnpm.io/zh/


#### 6.6.pnpm的存储store

- 在pnpm7.0之前，统一的存储位置是 ~/.pnpm-score中的；
  -  在pnpm7.0之后，统一的存储位置进行了更改：<pnpm home directory>/store
    - 在 Linux 上，默认是 ~/.local/share/pnpm/store
    -  在 Windows 上： %LOCALAPPDATA%/pnpm/stor
    -  在 macOS 上： ~/Library/pnpm/store
- 我们可以通过一些终端命令获取这个目录：获取当前活跃的store目录
  - pnpm store path
-  另外一个非常重要的store命令是prune（修剪）：从store中删除当前未被引用的包来释放store的空间
  - pnpm store prune	



## day50-邂逅Webpack和打包过程

### 一、认识webpack工具

#### 1.1.认识内置模块 path（路径）

- path 模块用于对路径和文件进行处理，提供了很多好用的方法。
- 我们知道在 Mac OS 、 Linux 和 window 上的路径时不一样的
  - window 上会使用 \ 或者 \\ 来作为文件路径的分隔符，当然目前也支持 / ；
  - 在 Mac OS 、 Linux 的 Unix 操作系统上使用 / 来作为文件路径的分隔符；
-  那么如果我们在 window 上使用 \ 来作为分隔符开发了一个应用程序，要部署到 Linux 上面应该怎么办呢？
  -  显示路径会出现一些问题；
  -  所以为了屏蔽他们之间的差异，在开发中对于路径的操作我们可以使用 path 模块；
- 可移植操作系统接口（英语： Portable Operating System Interface ，缩写为 POSIX ）
  -  Linux 和 Mac OS 都实现了 POSIX 接口；
  -  Window 部分电脑实现了 POSIX 接口；



#### 1.2.path 常见的 API

- ```
  //1.可以从一个路径中获取一些信息（了解）
  console.log(path.extname(filepath))//后缀名字
  console.log(path.basename(filepath))//文件名字
  console.log(path.dirname(filepath))//文件夹对应的路径
  
  
  //2.将多个路径拼接在一起:path.join
  const path1 = "/abc/cba"
  const path2 = "../ylj//kobe/james.txt"
  
  console.log(path.join(path1, path2))
  
  //3.将多个路径拼接在一起，最终一定会返回一个绝对路径（非常重要）： path.resolve
  console.log("---------------------")
  //从右向左进行拼接直到形成一个绝对路径就会停止，到最后到没有生成绝对路径就会使用当前工作目录比如下现在的  D:\临时\练习代码\前端工程化\04_Path模块的使用
  //  /绝对路径  ./相对路径
  console.log(path.resolve("./abc/cba", "./ylj/kobe", "./abc.txt") )
  //如果生成的路径尾部有/会自动删除尾部斜杠 零长度path段被忽略（""）
  // console.log(path.resolve("./abc/cba",  " ", ./ylj/kobe", "./abc.txt/") )
  
  //如果没有 path 传递段， path.resolve() 将返回当前工作目录的绝对路径
  console.log(path.resolve())
  ```

- 路径的拼接： path.join

  -  如果我们希望将多个路径进行拼接，但是不同的操作系统可能使用的是不同的分隔符；
  -  这个时候我们可以使用 path.join 函数

-  拼接绝对路径： path.resolve

  -  path.resolve() 方法会把一个路径或路径片段的序列解析为一个绝对路径；
  - 给定的路径的序列是从右往左被处理的，后面每个 path 被依次解析，直到构造完成一个绝对路径；
  -  如果在处理完所有给定 path 的段之后，还没有生成绝对路径，则使用当前工作目录；
  -  生成的路径被规范化并删除尾部斜杠，零长度 path 段被忽略；
  -  如果没有 path 传递段， path.resolve() 将返回当前工作目录的绝对路径；





### 二、 webpack基本打包

#### 2.1.认识webpack

- 官方的解释：
  -  webpack 是一个静态的 模块化 打包工具，为现代的 JavaScript 应用程序；
- 我们来对上面的解释进行拆解：
  - 打包 bundler ： webpack 可以将帮助我们进行打包，所以它是一个打包工具
  -  静态的 static ：这样表述的原因是我们最终可以将代码打包成最终的静态资源（部署到静态服务器）；
  -  模块化 module ： webpack 默认支持各种模块化开发， ES Module 、 CommonJS 、 AMD 等；
  -  现代的 modern ：我们前端说过，正是因为现代前端开发面临各种各样的问题，才催生了 webpack 的出现和发展；



#### 2.2.webpack的使用

- 项目里面没有package.json文件先 输入命令: npm init -y生成
- 然后安装webpack一般在局部安装 输入命令 npm install webpack webpack-cli -D
- 接着打包: npx webpack



#### 2.3.webpack的基本打包

- webpack的默认打包

  - /src/index.js  ->   dlist/main.js

- webpack指定入口和出口

- webpack的配置文件:webpack.config.js

  - output的path必须是绝对路径

  - ```
    const path = require("path")
    
    module.exports = {
      entry: "./src/main.js",
      output: {
        filename: "bundle.js",
        // path: path.resolve("./build")
        path: path.resolve(__dirname, "./build")
      }
    }
    ```

- webpack的配置文件的取名

  - 命令:webpack --config 名称

- webpack命令编写到package.json中的scripts 这样打包直接 输入命令npm run 名称

  - ```
    {
      "name": "01_webpack_basic",
      "version": "1.0.0",
      "main": "index.js",
      "scripts": {
          "build": "webpack --config wk.config.js"
      },
      "keywords": [],
      "author": "",
      "license": "ISC",
      "description": "",
      "devDependencies": {
        "webpack": "^5.95.0",
        "webpack-cli": "^5.1.4"
      }
    }
    ```

    



### 三、webpack配置文件

#### 3.1.

- webpack的配置文件:webpack.config.js

  - output的path必须是绝对路径

  - ```
    const path = require("path")
    
    module.exports = {
      entry: "./src/main.js",
      output: {
        filename: "bundle.js",
        // path: path.resolve("./build")
        path: path.resolve(__dirname, "./build")
      }
    }
    ```

- webpack的配置文件的取名

  - 命令:webpack --config 名称

- webpack命令编写到package.json中的scripts 这样打包直接 输入命令npm run 名称

  - ```
    {
      "name": "01_webpack_basic",
      "version": "1.0.0",
      "main": "index.js",
      "scripts": {
          "build": "webpack --config wk.config.js"
      },
      "keywords": [],
      "author": "",
      "license": "ISC",
      "description": "",
      "devDependencies": {
        "webpack": "^5.95.0",
        "webpack-cli": "^5.1.4"
      }
    }
    ```


#### 4.2.指定配置文件

- ![image-20241019115113898](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241019115113898.png)





### 四、编写和打包css文件

#### 4.1.webpack的依赖图

- webpack 是如何对我们的项目进行打包的？
  -  事实上 webpack 在处理应用程序时，它会根据命令或者配置文件找到入口文件；
  -  从入口开始，会生成一个 依赖关系图，这个依赖关系图会包含应用程序中所需的所有模块（比如 .js 文件、 css 文件、图片、
    字体等）；
  -  然后遍历图结构，打包一个个模块（根据文件的不同使用不同的 loader 来解析）；
- ![image-20241019115213640](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241019115213640.png)



#### 



### 五、编写和打包LESS文件

#### 5.1.编写案例代码

- 在src中创建component文件夹，在里面创建div_cpn.js文件

  - ```
    import "./css/div_style.css"
    
    //创建div元素
    const divEl = document.createElement("div")
    
    divEl.textContent = "hello world"
    divEl.classList.add("content")
    
    document.body.append(divEl)
    ```

  - 

- 在src中创建css文件,在里面创建div_style.css文件

  - ```
    .content {
      font-size: 20px;
      color: red;
    }
    ```

- 接着在src中的main,js文件中导入div的组件文件

  - ```
    import "./component/div_cpn"
    ```

- 然后输入命令 npm i webpack webpack-cli -D

- 再 npx webpack发现报错，因为没有css-loader

- 因此要在webpack.js的配置文件中添加module.rules

  - module.rules 中允许我们配置多个 loader （因为我们也会继续使用其他的 loader ，来完成其他文件的加载）

  - module.rules 的配置如下：

    -  rules 属性对应的值是一个数组： [Rule]

    -  数组中存放的是一个个的 Rule ， Rule 是一个对象，对象中可以设置多个属性：

      - test 属性：用于对 resource （资源）进行匹配的，通常会设置成正则表达式；
      - use 属性：对应的值时一个数组： [UseEntry]
        - UseEntry 是一个对象，可以通过对象的属性来设置一些其他属性
          - loader ：必须有一个 loader 属性，对应的值是一个字符串；
          - 下面两个后续讲解
          - options ：可选的属性，值是一个字符串或者对象，值会被传入到 loader 中；
          - query ：目前已经使用 options 来替代；
        - 传递字符串（如： use: [ 'style-loader' ] ）是 loader 属性的简写方式（如： use: [ { loader: 'style-loader'} ] ）；

      - loader 属性： Rule.use: [ { loader } ] 的简写。

    - ```
      const path = require("path")
      
      module.exports = {
        entry: "./src/main.js",
        output: {
          filename: "bundle.js",
          // path: path.resolve("./build")
          path: path.resolve(__dirname, "./build")
        },
        module: {
          rules: [
            {
              //告诉webpack要匹配什么文件
              test: /\.css$/,
              use: [
              //   //use中多个loader的使用顺序是从后往前的
                { loader: "style-loader" },
                 { loader: "css-loader" }
               ]
              //简写一：如果loader只有一个
              // loader: "css-loader"
              //简写二：
              //了解即可 不建议一开始就记住简写，因为这里面不止loader一个属性
              // use: [ "style-css", "css-loader"]
            }
          ]
        }
      }
      ```

    - 



### 六、postcss工具处理css(重看 运行不起来)







## Webpack打包图片-JS-Vue

### 一、Webpack打包图片

### 二、Webpack打包JS代码

### 三、Babel和babel-loader

### 四、Webpack打包Vue

### 五、resolve模块解析

#### 5.1.解析

- esolve 用于设置模块如何被解析
  -  在开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库；
  -  resolve 可以帮助 webpack 从每个 require/import 语句中，找到需要引入到合适的模块代码；
  -  webpack 使用 enhanced-resolve 来解析文件路径；
-  webpack 能解析三种文件路径：
- 绝对路径 由于已经获得文件的绝对路径，因此不需要再做进一步解析。
-  相对路径
  -  在这种情况下，使用 import 或 require 的资源文件所处的目录，被认为是上下文目录；
  -  在 import/require 中给定的相对路径，会拼接此上下文路径，来生成模块的绝对路径；
-  模块路径
  -  在 resolve.modules 中指定的所有目录检索模块；
  -  默认值是 ['node_modules'] ，所以默认会从 node_modules 中查找文件；
- -  我们可以通过设置别名的方式来替换初识模块路径，具体后面讲解 alias 的配置；





## Webpack常见的插件和模式(重看)

### 一、认识插件Plugin

#### 1.1.认识Plugin

- Webpack的另一个核心是Plugin，官方有这样一段对Plugin的描述：
  -  While loaders are used to transform certain types of modules, plugins can be leveraged to perform a wider range
    of tasks like bundle optimization, asset management and injection of environment variables.
  - 翻译过来就是：
  -  Loader是用于特定的模块类型进行转换；
  -  Plugin可以用于执行更加广泛的任务，比如打包优化、资源管理、环境变量注入等；
- 

### 二、CleanWebpackPlugin

### 三、HtmlWebpackPlugin

### 四、DefinePlugin

### 五、mode模式配置





## Git版本控制工具详解(非常重要一定要掌握)

### 一、邂逅版本控制工具

#### 1.1.认识版本控制

- 版本控制（Version control）
  - 是维护工程蓝图的标准作法  能追踪工程蓝图从诞生一直到定案的过程
  - 版本控制也是一种软件工程技巧  借此能在软件开发的过程中  确保由不同人所编辑的同一程序文件都得到同步
- 版本控制在软件开发中可以帮助程序员进行代码的追踪、维护、控制等等一系列的操作



#### 1.2.版本控制的功能

- 不同版本的存储管理
  - 一个项目会不断更新 可能增加新功能 需求 或者对整个项目进行重构
  - 若手动维护一系列先前版本的备份 会非常麻烦
- 重大版本的备份维护
  - 对于很多重大的版本 我们会进行备份管理
- 恢复之前的项目版本
  - 若有一天开发遇到严重的问题想要恢复先前的某个版本
  - 这就像快照一样 遇到问题就可以恢复
- 记录项目的点点滴滴
  - 如果我们每一个功能的修改 bug的修复  新的需求更改都需要记录下来 版本控制可以很好的解决
- 多人开发的代码合并
  - 项目中通常是多人开发  将多人代码进行合并  并且在出现冲突时更好的进行处理



#### 1.3.版本控制的历史(了解)

- 没有版本控制之前
  - 通常进行文件备份的方式来管理  再通过diff命令来对比两个文件的差异
- CVS
  - 第一个被大规模使用的版本控制工具
- SVN
  - 和CVS一样  都属于集中式版本控制工具
  - 已被GIt取代
- GIt
  - Linus的作品



### 二、集中式和分布式区别

#### 2.1.集中式版本控制

- CVS和SVN都是集中式版本控制系统(Centralized Version Control Systems,简称CVCS)
  - 主要特点: 单一的集中管理的服务器  保存所有文件的修订版本
  - 协同开发人员通过客户端连接到这台服务器  取出最新的文件或者提交更新
  - ![image-20241020111436541](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241020111436541.png)
  - 这种做法带来了许多好处，特别是相较于老式的本地管理来说，每个人都可以在一定程度上看到项目中的其他人正在做些什么。
  -  但是集中式版本控制也有一个核心的问题：中央服务器不能出现故障：
    - 如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作；
    - 如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据；



#### 2.2.分布式版本控制

- GIt属于分布式版本控制 (Distributed Version Control System ) 简称DVCS
  - 客户端并不只提交最新版本的快照  而是把代码仓库完整地镜像下来  包括完整的历史记录
  - 这样若服务器A发生故障 那本都服务器就可以将提取的所有历史记录包括最新版本快照推送到另一台新的服务器中 (即可以用任何一个镜像出来的本地仓库恢复)
  - 因为每一次的克隆操作 实际上是一次对代码仓库的完整备份

- ![image-20241020112439343](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241020112439343.png)

#### 2.3.总结

- 集中式是将整个仓库放到服务器
- 分布式是每台电脑都有对应的仓库 可以在本地提交 再将本地的仓库同步到服务器仓库



### 三、Git的环境安装搭建

#### 3.1.Git的安装



#### 3.2.Bash-CMD-GUI区别

- Bash，Unix shell 的一种，Linux 与 Mac OS X 都将它作为默认 shell。
  -  Git Bash 就是一个 shell，是 Windows 下的命令行工具，可以执行 Linux 命令；
     Git Bash 是基于 CMD 的，在 CMD 的基础上增添一些新的命令与功能；
  - 所以建议在使用的时候，用 Bash 更加方便

- Git CMD
  -  命令行提示符（CMD）是 Windows 操作系统上的命令行解释程序；
  -  当你在 Windows 上安装 git 并且习惯使用命令行时，可以使用 cmd 来运行 git 命令
-  Git GUI
  -  基本上针对那些不喜欢黑屏（即命令行）编码的人；
  -  它提供了一个图形用户界面来运行 git 命令；



#### 3.3.git的基本使用

- 设置用户名和地址
  - 使用了--global选项该命令只需要运行一次会自动保存到配置当中
  - git config --global user.name "1ylj"
  - git config --global user.email "1565426625@qq.com"
- 检测当前的配置信息
  - git config --list



#### 3.4.Git的别名(了解 一般不配置)

- ![image-20241023140942669](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241023140942669.png)

#### 3.5.





### 四、Git初始化本地仓库

#### 4.1.获取git仓库 -git init/git clone

- 两种方式
  - 方式一:初始化一个GIt仓库
    -  该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的核心；
    - 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪；
    - git init
  - 方式二:从其他服务器克隆一个已存在GIt仓库
    - git clone 地址



#### 4.2.文件的状态划分

- 实际开发中需要将某些文件交到git仓库中进行管理
- 并之后我们会对这些文件进行修改 当达到某一个目标时 想要记录下来这次操作 就会将他提交到仓库中
- 文件划分为不同的状态 以确定文件是否归于Git仓库的管理
  - 未跟踪:默认情况下 Git仓库下的文件也没有添加到Git仓库中 我们需要使用add命令来操作
  - 已跟踪: 添加到Git仓库管理的文件处于已跟踪状态 Git可以对其进行各种跟踪管理
- 已跟踪的文件又可以进行细分状态划分：
  -  staged：暂缓区中的文件状态；
  -  Unmodified：commit命令，可以将staged中文件提交到Git仓库
  -  Modified：修改了某个文件后，会处于Modified状态；



#### 4.3.检测文件的状态-file status

- 通过命令git status
- 也可以通过 git status -s /git status --short
  - 看的比较简洁





### 五、Git记录更新变化过程

#### 5.1.基本使用

- 使用git status查看状态
  -  staged：暂缓区中的文件状态；
  -  Unmodified：commit命令，可以将staged中文件提交到Git仓库
  -  Modified：修改了某个文件后，会处于Modified状态；
- 使用 git add aaa.js 可以将文件添加到索引
  - git add .  表示添加到 可以提交的区域 (添加到暂缓区)
- git commit -m  ""//可以对此次修改进行文字描述等等
- git commit -a -m ""表示先添加再提交 就不用每次都执行两次命令



- git log可以查看列表中还有哪些文件没有提交



#### 5.2.git忽略文件

- .gitignore
  - 一般会有些文件不需要纳入git管理 也不希望出现在未跟踪文件列表
  - 通常这些文件是自动生成的文件  比如日志文件
- 因此会创建gitignore文件列出需要忽略的文件的模式

- 在实际开发中这些文件不需要手动创建 在必须得时候添加自己忽略内容即可

- ![image-20241020164348534](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241020164348534.png)



#### 5.3.Git的校验和

-  Git 中所有的数据在存储前都计算校验和，然后以 校验和 来引用。
  - Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）；
  - 这是一个由 40 个十六进制字符（0-9 和 a-f）组成的字符串，基于 Git 中文件的内容或目录结构计算出来；

- ![image-20241020164003797](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241020164003797.png)
- 



#### 5.4.查看提交的历史-Git log

- ![image-20241020170546119](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241020170546119.png)

- git log --pretry=oneline --graph
  - 以图结构来展示



#### 5.5.版本的回退-git reset

- Git通过head进行回退

- ![image-20241020171105581](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241020171105581.png)

- 通过head来改变git目前的版本执行

  - 上一个版本HEAD^  上上一个版本HEAD^^
  - 如果是上千个版本 我们可以使用HEAD~1000
  - 我们可以选择指定某一个commint id
  - ![image-20241020171849597](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241020171849597.png)

  - git reflog恢复记录
  - ![image-20241020172352273](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241020172352273.png)



### 六、Git远程仓库和验证

#### 6.1.什么是远程仓库

- 多人将管理的代码共享到远程仓库
- ![image-20241021084023121](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241021084023121.png)
- ![image-20241021085429012](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241021085429012.png)

#### 6.2.远程仓库的验证

- 凭证
  - HTTP协议是无状态连接  所以每一个连接都需要用户名和密码
    - 但每次这样操作很麻烦
- SSH密钥
  - 输入ssh-keygen 
  - 在自己电脑上找到.shh文件将文件里面的公共密钥复制粘贴到远程仓库的ssh上面




#### 6.3.和远程仓库连接步骤

- 如果想要把自己的项目push到远程仓库上面
- 第一要初始化建立本地仓库
  - git init
  - 所有的文件都会显示未跟踪
- 第二步
  - git add .
  - 将所有文件加入到暂缓区
- 再进行提交
  - git commit -m ""
- 第四步  建立远程仓库连接
  - git remote add oringin(这个名字可以自己定义) url
  - 可以通过git remote -v查看远程仓库连接的列表
- 第五步:要将两个毫不相关的两个分支进行合并必须建立上游分支(可以理解为必须要有共同的祖先才能进行合并)  ->是从git 2.9版本以后加上的限制 ,防止其他使用者乱合并
  - git merge --allow-unrelated-histories
- 第六步:将所有push到远程仓库
  - git push



#### 6.4.远程仓库的交互

- 从远程仓库clone代码:将存储库克隆到新创建的目录中  ->克隆下来的最后 可以直接push
  - git clone url
- 将代码push到远程仓库:将本地仓库的代码推送到远程仓库上
  - 默认情况下是将当前分支push搭配origin远程仓库
  - git push 
  - git push origin master
- 从远程仓库fetch代码: 从远程仓库获取最新的代码
  - 默认情况下是从origin获取代码
  - git fetch
  - git fetch origin master
  - 获取到代码后默认并没有合并到本地仓库 只是缓存到了本地仓库的某个位置
  - git merge
  - git merge origin/master
- 从远程仓库pull代码:上面的两次操作有点繁琐 我们可以通过一个命令来操作
  - git pull 
  - git fetch + git merge(rebase)



#### 6.5.总结-远程仓库的操作

##### 1.情况一:到公司已经有项目并且有远程仓库

- git clone url
- 进行开发
- git add .
- git committ -m ""
- git pull -> git fetch/git fetch
- git push

##### 2.情况二:开发一个全新的项目 由自己搭建 

- 创建一个远程仓库
- 方案一:
  - git clone url
  - 在clone下来文件夹中开始搭建整个项目
  - git add .
  - gi commit -m ""
  - git push
- 方案二:
  - 搭建一个本地仓库和搭建本地项目
    - git remote add oringin url
    - git branch --set-upstream-to=origin/master
    - git fetch
    - git merge --allow-unrelated-histories
    - git push



##### Gitlab远程仓库连接

- 创建一个项目
- git clone gitlab_url
  - 要验证 -> 公钥  /  ->  输入账号密码



##### Github远程仓库连接

- git init 初始化项目创建一个本地仓库
- git add .
- git commit -m ""
- git remote add url  //建立远程连接
- git fetch 获取远程仓库的资源
-  git merge origin/main --allow-unrelated-histories  //将远程仓库的main分支合并一起  最后一句是：允许不相关的历史进行合并
-  git branch --set-upstream-to=origin/main  //建立分支
-  git pull
-  git push origin head:main  /  git push origin master:main  -> 意思是将本地的master分支推送到远程的main分支
  - 或者git checkout -b  main  --track origin/main  跟踪远程的main分支  也在本地创建main分支 两者名字一样就不需要上述这条命令要指定head  因为两个分支名字一样



切换不同分支 

- git checkout master/main(分支名称)



- 补充说明
- ![image-20241022094114123](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241022094114123.png)
- ![image-20241022094207755](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241022094207755.png)

- ![image-20241022094506291](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241022094506291.png)



### 七、Git的标签tag用法

- 添加标签
  - git tag 名字
  - ![image-20241022101701898](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241022101701898.png)

- 推送tag到远程仓库
  - ![image-20241022103059615](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241022103059615.png)
- 删除本地tag
  - git tag -d xxxx  这只是删除本地的远程的还没有被删除

- 删除远程tag
  -  git push origin -d xxxx



### 补充内容

- ![image-20241022204632407](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241022204632407.png)
- GIt提交对象
  - 在进行提交是git会保存一个提交对象 
    - 这个对象会包含一个暂存内容快照的指针
    - 提交对象还包含了作者的姓名邮箱 提交时输入的信息以及指向它的父对象的指针
      - 首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象；
      - 而由多个分支合并产生的提交对象有多个父对象；

- ![image-20241023142148159](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241023142148159.png)



### 八、Git分支的使用过程

#### 8.1.创建分支同时切换

- git branch 分支名称

- ![image-20241022214104481](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241022214104481.png)

- GIt创建分支
  - git checkout -b 分支名称  (表示创建一个分支并且跟踪)
  - git checkout 分支名称 可以切换分支


- ![image-20241023142346612](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241023142346612.png)

![image-20241023142605857](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241023142605857.png)

#### 8.2.分支开发和合并

- 分支上开发 修复bug
  - 我们可以在创建hotfix分支上继续开发工作或者修复bug
  - 当完成要做的工作后 重新打上一个新的tagv1.0.1
- 切换到master分支 但这个时候master分支也需要刚才修复的Bug 所以需要我们将master分支和hotfix分支进行合并
  - 命令: git checkout master 切换到master分支
  - 命令:git merge hotfix 合并分支

#### 8.3.查看和删除分支

- 查看当前所有的分支

- git  branch 
  - 查看当前所有的分支
- git branch -v 同时查看最后一次提交
- git branch --merge 查看所有合并到当前分支的分支
- git branch --no -merged 查看所有母合并到当前分支的分支
- 删除分支
- git branch -d 分支名称
- git branch -D 分支名称   强制删除某一个分支





### 九、工作中得到Git  Flow

#### 9.1.git 的工作流 (Git flow)

- ![image-20241023143411531](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241023143411531.png)

#### 9.2.比较常见的git flow

- ![image-20241023143643855](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241023143643855.png)



### 十、GIt远程分支的管理

#### 10.1.git的远程分支

- ![image-20241023145136992](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241023145136992.png)

- ![image-20241023145500901](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241023145500901.png)

- 方法二
- ![image-20241023145908329](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241023145908329.png)

- 删除分支
- ![image-20241023153419512](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241023153419512.png)

### 十一、Git rebase的使用

#### 10.1.使用

- ![image-20241023155741703](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241023155741703.png)



#### 10.2.原理

- ![image-20241023155817557](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241023155817557.png)



#### 10.3.rebase和merge的选择

- ![image-20241023155941308](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241023155941308.png)



### 十二、Git常见命令速查表

- ![image-20241023155831941](%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20241023155831941.png)



